/*
═══════════════════════════════════════════════════════════════════
QUERY: Base para Análise de Safra (Coorte)
═══════════════════════════════════════════════════════════════════

OBJETIVO:
    Extrair o histórico de faturamento dos últimos 5 anos para montar
    a análise de coorte no Python. A query já calcula a safra (mês da
    primeira compra) e o mês de vida de cada transação.

PERGUNTA DE NEGÓCIO:
    "Dos clientes que entraram em um determinado mês, quantos ainda
    estão comprando 1, 2, 3... meses depois?"

COMO ESTA QUERY SE CONECTA AO PYTHON:
    1. Você executa esta query no SQL Server (SSMS ou DBeaver)
    2. Exporta o resultado como CSV ou conecta via pyodbc
    3. O script analise_safra.py lê o CSV e faz a análise

    No portfólio, esse passo é simulado com dados sintéticos gerados
    por generate_sample_data.py. Mas a query está pronta para uso real.

COLUNAS RETORNADAS:
    - cliente_id       → identificador único do cliente
    - data             → data da transação (faturamento)
    - receita          → valor faturado (R$)
    - canal            → canal de venda (PME, Corporativo, etc.)
    - produto          → nome do produto (Vale Alimentação, etc.)
    - safra            → mês da primeira compra do cliente (YYYY-MM)
    - meses_de_vida    → quantos meses se passaram desde a safra
    - primeira_compra  → data exata da primeira transação
    - ultima_compra    → data exata da última transação

    O script Python espera no mínimo: cliente_id, data, receita.
    As demais colunas são opcionais e permitem segmentações adicionais
    (por canal, por produto, etc.)

BANCO DE DADOS ESPERADO:
    - dbo.faturamento  → tabela de fatos (uma linha por transação)
    - dbo.clientes     → dimensão de clientes (canal, região, gerência)
    - dbo.produtos     → dimensão de produtos (nome, tipo)

PRÉ-REQUISITOS:
    - SQL Server 2016+ (usa window functions e FORMAT)
    - Acesso de leitura às tabelas acima

TEMPO ESTIMADO DE EXECUÇÃO:
    ~5-15 segundos para 5 anos de dados (~100K-500K registros)

AUTOR: Igor Pereira Pinto
═══════════════════════════════════════════════════════════════════
*/


-- ═══════════════════════════════════════════════════════════════
-- CTE 1: PRIMEIRA E ÚLTIMA COMPRA DE CADA CLIENTE
-- ═══════════════════════════════════════════════════════════════
-- Por que uma CTE e não subquery?
--   CTEs são mais legíveis, reutilizáveis e fáceis de debugar.
--   Em queries complexas, cada CTE funciona como um "passo" lógico.
--
-- O que MIN e MAX fazem aqui:
--   MIN(data_faturamento) → primeira compra (define a safra)
--   MAX(data_faturamento) → última compra (indica se ainda está ativo)

WITH vida_cliente AS (
    SELECT
        f.cliente_id,
        MIN(f.data_faturamento)     AS primeira_compra,
        MAX(f.data_faturamento)     AS ultima_compra,
        COUNT(DISTINCT
            FORMAT(f.data_faturamento, 'yyyy-MM')
        )                           AS meses_com_compra,
        COUNT(*)                    AS total_transacoes,
        SUM(f.valor_faturamento)    AS receita_total
    FROM
        dbo.faturamento f
    WHERE
        f.valor_faturamento > 0                          -- Exclui estornos e cancelamentos
        AND f.status_faturamento = 'Efetivado'           -- Apenas faturamentos confirmados
        AND f.data_faturamento >= DATEADD(YEAR, -5, GETDATE())  -- Últimos 5 anos
    GROUP BY
        f.cliente_id
),


-- ═══════════════════════════════════════════════════════════════
-- CTE 2: CLASSIFICAR A SAFRA DE CADA CLIENTE
-- ═══════════════════════════════════════════════════════════════
-- A safra é o mês da primeira compra, no formato YYYY-MM.
-- Exemplo: cliente que comprou pela 1ª vez em 15/jan/2023 → safra "2023-01"
--
-- DATEDIFF calcula quantos meses se passaram entre a safra e cada transação.
-- Isso gera o "mês de vida" (periodo_idx no Python):
--   M0 = mês da primeira compra
--   M1 = 1 mês depois
--   M2 = 2 meses depois, e assim por diante.

safra_cliente AS (
    SELECT
        cliente_id,
        primeira_compra,
        ultima_compra,
        meses_com_compra,
        total_transacoes,
        receita_total,
        FORMAT(primeira_compra, 'yyyy-MM')  AS safra
    FROM
        vida_cliente
)


-- ═══════════════════════════════════════════════════════════════
-- QUERY PRINCIPAL: HISTÓRICO COM SAFRA E MESES DE VIDA
-- ═══════════════════════════════════════════════════════════════
-- Junta o faturamento transacional com a safra do cliente.
-- Cada linha do resultado é uma transação enriquecida com:
--   - A safra do cliente (mês de entrada)
--   - Quantos meses se passaram desde a entrada (meses_de_vida)
--   - Canal e produto para segmentações futuras
--
-- EXPLICAÇÃO PARA LEIGOS:
--   Esta query pega cada venda dos últimos 5 anos e adiciona
--   a informação de "quando esse cliente começou a comprar".
--   Com isso, conseguimos agrupar clientes por turma de entrada
--   e acompanhar quantos continuaram comprando mês a mês.

SELECT
    f.cliente_id,
    f.data_faturamento                                  AS data,
    f.valor_faturamento                                 AS receita,

    -- Dimensões para segmentação (opcionais no Python)
    c.canal_venda                                       AS canal,
    c.regiao                                            AS regiao,
    c.gerencia                                          AS gerencia,
    p.nome_produto                                      AS produto,
    CASE
        WHEN p.nome_produto IN ('Vale Alimentação', 'Vale Refeição', 'Vale Combustível')
        THEN 'recorrente'
        ELSE 'complementar'
    END                                                 AS tipo_produto,

    -- Safra e ciclo de vida
    sc.safra,
    sc.primeira_compra,
    sc.ultima_compra,
    DATEDIFF(
        MONTH,
        sc.primeira_compra,
        f.data_faturamento
    )                                                   AS meses_de_vida,

    -- Métricas do ciclo de vida do cliente (para contexto)
    sc.meses_com_compra,
    sc.total_transacoes,
    sc.receita_total                                    AS receita_total_cliente

FROM
    dbo.faturamento         f
    INNER JOIN dbo.clientes c   ON f.cliente_id = c.cliente_id
    INNER JOIN dbo.produtos p   ON f.produto_id = p.produto_id
    INNER JOIN safra_cliente sc ON f.cliente_id = sc.cliente_id

WHERE
    f.valor_faturamento > 0
    AND f.status_faturamento = 'Efetivado'
    AND f.data_faturamento >= DATEADD(YEAR, -5, GETDATE())

ORDER BY
    sc.safra,                    -- Agrupa por coorte de entrada
    f.cliente_id,                -- Dentro da coorte, por cliente
    f.data_faturamento;          -- Dentro do cliente, cronológico


/*
═══════════════════════════════════════════════════════════════════
ÍNDICES RECOMENDADOS (para performance)
═══════════════════════════════════════════════════════════════════

Se a query estiver lenta, estes índices ajudam:

-- Na tabela de faturamento (a mais consultada):
CREATE NONCLUSTERED INDEX IX_faturamento_cliente_data
ON dbo.faturamento (cliente_id, data_faturamento)
INCLUDE (valor_faturamento, status_faturamento, produto_id);

-- Na tabela de clientes:
CREATE NONCLUSTERED INDEX IX_clientes_canal
ON dbo.clientes (cliente_id)
INCLUDE (canal_venda, regiao, gerencia);


═══════════════════════════════════════════════════════════════════
COMO EXPORTAR O RESULTADO PARA O PYTHON
═══════════════════════════════════════════════════════════════════

OPÇÃO 1 — Exportar como CSV no SSMS:
    1. Execute a query
    2. Clique com botão direito no resultado → "Save Results As..."
    3. Salve como CSV na pasta data/ do projeto
    4. O script Python lê automaticamente

OPÇÃO 2 — Conexão direta via Python (pyodbc):
    import pyodbc
    import pandas as pd

    conn = pyodbc.connect(
        "DRIVER={ODBC Driver 17 for SQL Server};"
        "SERVER=seu_servidor;"
        "DATABASE=seu_banco;"
        "Trusted_Connection=yes;"      # ou UID=usuario;PWD=senha;
    )

    df = pd.read_sql(open("sql/query_base_safra.sql").read(), conn)
    df.to_csv("data/base_vendas_historica.csv", index=False)

OPÇÃO 3 — Via Power Query (Excel):
    1. Dados → Obter Dados → Do SQL Server
    2. Cole esta query no editor avançado
    3. Exporte como CSV para a pasta data/


═══════════════════════════════════════════════════════════════════
VALIDAÇÃO PÓS-EXTRAÇÃO (rode no SSMS para conferir)
═══════════════════════════════════════════════════════════════════

-- Total de registros (esperado: 100K-500K para 5 anos)
SELECT COUNT(*) AS total_registros FROM dbo.faturamento
WHERE data_faturamento >= DATEADD(YEAR, -5, GETDATE());

-- Total de clientes únicos
SELECT COUNT(DISTINCT cliente_id) AS total_clientes FROM dbo.faturamento
WHERE data_faturamento >= DATEADD(YEAR, -5, GETDATE());

-- Distribuição por canal (conferir se todos os canais aparecem)
SELECT c.canal_venda, COUNT(DISTINCT f.cliente_id) AS clientes
FROM dbo.faturamento f
INNER JOIN dbo.clientes c ON f.cliente_id = c.cliente_id
WHERE f.data_faturamento >= DATEADD(YEAR, -5, GETDATE())
GROUP BY c.canal_venda
ORDER BY clientes DESC;

-- Meses sem dados (gaps na série temporal — não deveria haver)
SELECT FORMAT(data_faturamento, 'yyyy-MM') AS mes, COUNT(*) AS registros
FROM dbo.faturamento
WHERE data_faturamento >= DATEADD(YEAR, -5, GETDATE())
GROUP BY FORMAT(data_faturamento, 'yyyy-MM')
ORDER BY mes;

═══════════════════════════════════════════════════════════════════
*/
